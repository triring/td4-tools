# TD4 エミュレータ by tinygo 利用マニュアル
<!-- pandoc -f markdown -t html5 -o README.html -c github.css README.md -->

## 1. 概要

本ツールは、渡波郁氏の著書 [CPUの創りかた](https://book.mynavi.jp/ec/products/detail/id=22065) で紹介された、学習や実験を目的に設計開発された4bit CPU「TD4 (**T**ada **D**ousa-suru-dake-no)」の動作をソフトウェア上で再現するエミュレータです。  
オリジナルは、go 言語で記述したエミュレータ[td4emu](../td4emu/README.md)で、これをマイコンボード上でも使えるようにtinygoで書き換え移植しました。  
現在、以下の3種類があります。


* [core](./core/README.md)

    - 一番最初に作成したバージョン。手元にあったRaspi picoでテストし、動作を確認済み。  
    - OSのコンソール上で動いていた[td4emu](../td4emu/README.md)を、マイコンボード＋シリアルターミナルで動くようにしただけなので、一般のOS上で動くGo版と全く変わらない。
    - 特別な機能を使っていないので、tinygoがサポートするマイコンボードであれば、コンパイル時にターゲットに使用するマイコンボードを指定すればそのまま使用可能。  

* [RasPiPico](./RasPiPico/README.md)

    - core版を拡張し、Out命令による出力の最下位ビットをRaspi picoのLEDに割当てています。これにより、LEDのOn、Off制御ができます。

* [MAKER-PI-RP2040](./MAKER-PI-RP2040/README.md)
    - Cytron Maker Pi RP2040は、Raspi pico と同じマイクロコントローラRP2040をロボット制御ボードに組み込んだ製品
    - このボード上に搭載されているユーザボタンとLEDをIn命令とOut命令で制御できるようにしました。
    - In命令による入力2ビットを2個のユーザボタンに割り当てました。
    - Out命令による出力4ビットを4個のLEDに割り当てました。

詳細については、それぞれバージョン用のREADME.mdをお読み下さい。

* [./core/README.md](./core/README.md)
* [./RasPiPico/README.md](./RasPiPico/README.md)
* [./MAKER-PI-RP2040/README.md](./MAKER-PI-RP2040/README.md)

エミュレータとしての基本機能は共通なので、以下の解説とコマンドマニュアルをお読み下さい。

**主な機能:**

* **トレース実行機能**: 1命令ずつ確認しながら実行可能（デバッグに最適）。
* **実行速度調整**: クロック周波数（待機時間）を任意に設定可能。
* **状態表示**: PC（プログラムカウンタ）、レジスタA/B、キャリーフラグ(C)、出力ポート(OUT)をリアルタイム表示。

## 2. 使用するTD4のバイナリ形式

本エミュレータが読み込むROMファイルは、**「テキスト形式の16進数リスト」** です。
バイナリファイル (.bin) ではなく、アセンブラ[td4asm](../td4asm/README.md)が出力したHEXコードをテキストファイルとして保存したものを使用します。拡張子は、 (.hex) として下さい。 

### ファイルフォーマット仕様

出力されるhexファイルの中身は、S コマンドと同じ書式 になっています。  

```text
S adr opc1 opc2 opc3 ...
```

以下は、その出力例です。

```text
S 0x00 0x30 0x01 0x02 0x04 0x08 0x40 0x90 0xF7
```

* 行の先頭は、`S`から始まります。
* 2つ目は、書き込み開始アドレスです。
* それ以降に、書き込むバイナリデータで、値は go**16進数** で表記しています。
* それぞれのデータ間は、スペースで区切っています。
* 最大 **16バイト** まで読み込まれます（TD4の仕様）。
* 行の先頭に`;`があると、コメントとして無視されます。

## 3. コンパイル方法

本ツールはGo言語で記述されています。実行ファイルを生成し、マイコンボードに書き込むにはtinygoの開発環境が必要です。  
開発環境が、まだインストールされていない場合は、[TinyGo言語公式サイトのQuick install guide](https://tinygo.org/getting-started/install/)を参照して、インストールしておいてください。  
ターミナル（WindowsならコマンドプロンプトやPowerShell、Mac/LinuxならTerminal）を開き、ソースコード(`main.go`)があるディレクトリで、以下のコマンドを入力して実行してください。  

### 手順

ターミナル（コマンドプロンプト）を開き、ソースコードがあるディレクトリで以下のコマンドを実行します。

**Windowsの場合:**

```cmd
tinygo flash -target=pico -size=short -monitor .
```

**Mac / Linuxの場合:**

```bash
tinygo flash -target=pico -size=short -monitor .
```

何もエラーが表示されなければ、実行ファイルがマイコンボードに書き込みが行われます。  
そして、以下のように表示されればコンパイル成功です。

```bash
> tinygo flash -target=pico -size=short -monitor .
   code    data     bss |   flash     ram
  75464    1596    5200 |   77060    6796
Connected to COM15. Press Ctrl-C to exit.
4bit CPU TD4 emulator
Reading from the serial port...
Mode: Step=true, Speed= 1000ms/inst
| PC   BP |OP-code|A register |B register |Cflag| IN port | OUT port |
|:--------|:-----:|:---------:|:---------:|:---:|:-------:|:--------:|
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
```

## 4. 操作方法

コンソールから、コマンドを入力しながら、実行していきます。

### 画面表示の見方

実行中、コンソールには以下のようなCPUの内部状態が表示されます。  
これをコピペして、markdown形式のテキストに貼り付けると、テーブルとして表示できます。  

```text
| PC   BP |OP-code|A register |B register |Cflag| IN port | OUT port |
|:--------|:-----:|:---------:|:---------:|:---:|:-------:|:--------:|
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
```

* **PC** : プログラムカウンタ（現在の実行アドレス 00-15）
* **OP** : 命令コード（16進数）
* **A**  : Aレジスタの値 [2進数(16進数)]
* **B**  : Bレジスタの値 [2進数(16進数)]
* **C**  : キャリーフラグ（1=ON, 0=OFF）
* **IN** : 入力ポートの状態（物理スイッチのOnOff状態に相当）
* **OUT**: 出力ポートの状態（LEDの点灯状態に相当）


### 基本コマンド

##### Q コマンド
**Q** : プログラムを終了します。

```bash
> Q
program terminated !
```

##### H コマンド

**H** : 使用方法を表示します。  

```bash
> H
Command list
        H :(Help) コマンドの使用方法を表示する。
        D :(Dump) 現在のCPUのレジスタ内容を表示する。
        M :(Memory) 現在の現在のメモリの内容を表示する。
        B [bp] :(Breakpoint) ブレークポイントの設定と削除を行う。
        T [count] :(Trace) プログラムを指定回数だけ命令を実行する（ステップ実行）。
        V [speed] :(Velocity) 実行速度を設定する。
        G [address] :(Go) 指定したアドレスからプログラムの実行を開始する。
        S [address] [opcode] [opcode] ... :(Setdata) 指定したメモリ番地にオペコードを書き込む。
        I [bit pattern] :(InPort) 入力ポートの値を設定する。
        Q :(Quit) モニタプログラムを終了する。

```

##### M コマンド

**M** : 現在のROM内容を表示します。  
以下は、M コマンドによる実行例です。  
プログラムを起動後、M コマンドでROM内容を表示しています。  
当然ですが、プログラムは何もないので、すべて`0`で埋め尽くされています。  

```bash
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x00 0b0000_0000 |
|   01   | 0x00 0b0000_0000 |
|   02   | 0x00 0b0000_0000 |
|   03   | 0x00 0b0000_0000 |
|   04   | 0x00 0b0000_0000 |
|   05   | 0x00 0b0000_0000 |
|   06   | 0x00 0b0000_0000 |
|   07   | 0x00 0b0000_0000 |
|   08   | 0x00 0b0000_0000 |
|   09   | 0x00 0b0000_0000 |
|   10   | 0x00 0b0000_0000 |
|   11   | 0x00 0b0000_0000 |
|   12   | 0x00 0b0000_0000 |
|   13   | 0x00 0b0000_0000 |
|   14   | 0x00 0b0000_0000 |
|   15   | 0x00 0b0000_0000 |
```

##### S コマンド

**S** adr opc1 opc2 opc3 ... : 指定したアドレスのコードを書き込みます。  
起動直後は、何も命令が書き込まれていない状態です。
ここに、コードを書き込むために使用します。  
また、以下のようなを試行錯誤していく場合に、毎回、ソースコードを編集してアセンブルし直していたのでは、手間と時間の無駄です。  

* 定数を変更した時に結果がどの様に変わるか
* コードの一部を修正したい。

そのような場合に、直接、修正したい部分のコードを書き換える事ができます。
その書式は、以下の通りです。

```text
S adr opc1 opc2 opc3 ... 
```

* 行の先頭は、`S`から始まります。
* 2つ目は、書き込み開始アドレスです。
* それ以降に、書き込むバイナリデータで、値は go**16進数** で表記しています。
* それぞれのデータ間は、スペースで区切っています。

以下は、複数回の加算を行い、結果をOutPortに出力するものです。

1. Aレジスタで、1+2+4+8を計算する。
2. Aレジスタの内容をBレジスタにコピーする。
3. Bレジスタの内容をOutPortに出力する。
4. 現在のアドレスにジャンプして停止状態にする。

```bash
> type .\Summation.td4
; 加算	Summation
    MOV A, 0       ; Aレジスタに 0 を代入し、初期化
    ADD A, 0b00_01 ; Aレジスタに 1 を加算( 2進数)
    ADD A, 0o02    ; Aレジスタに 2 を加算( 8進数)
    ADD A, 4       ; Aレジスタに 4 を加算(10進数)
    ADD A, 0x8     ; Aレジスタに 8 を加算(16進数)
    MOV B, A       ; Aレジスタの値をBレジスタにコピーする。
    OUT B          ; Bレジスタの値を出力ポートに送る。
STOP:
    JMP STOP ; ここで無限ループにして、停止状態にする。
```

これをアセンブルすると、hexファイルが生成されます。
その中には、書き込み用のテキストデータが書き込まれています。

```bash
> .\td4asm.exe -o .\Summation.hex -list .\Summation.td4

 ADDR      | BINARY    | HEX | SOURCE CODE
-----------|-----------|-----|----------------
 00 [0000] | 0011_0000 |  30 | MOV A, 0
 01 [0001] | 0000_0001 |  01 | ADD A, 1
 02 [0010] | 0000_0010 |  02 | ADD A, 2
 03 [0011] | 0000_0100 |  04 | ADD A, 4
 04 [0100] | 0000_1000 |  08 | ADD A, 8
 05 [0101] | 0100_0000 |  40 | MOV B, A
 06 [0110] | 1001_0000 |  90 | OUT B
 07 [0111] | 1111_0111 |  F7 | JMP STOP

Success! Generated 8 bytes.
Output saved to '.\Summation.hex'

> type .\Summation.hex
S 0x00 0x30 0x01 0x02 0x04 0x08 0x40 0x90 0xF7
```

以下は、S コマンドによる実行例です。  
起動後に、M コマンドでROM内容を表示しています。
先程の加算プログラムを書き込み、再度、M コマンドでROM内容を表示しています。

```bash
4bit CPU TD4 emulator
Reading from the serial port...
Mode: Step=true, Speed= 1000ms/inst
| PC   BP |OP-code|A register |B register |Cflag| IN port | OUT port |
|:--------|:-----:|:---------:|:---------:|:---:|:-------:|:--------:|
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x00 0b0000_0000 |
|   01   | 0x00 0b0000_0000 |
|   02   | 0x00 0b0000_0000 |
|   03   | 0x00 0b0000_0000 |
|   04   | 0x00 0b0000_0000 |
|   05   | 0x00 0b0000_0000 |
|   06   | 0x00 0b0000_0000 |
|   07   | 0x00 0b0000_0000 |
|   08   | 0x00 0b0000_0000 |
|   09   | 0x00 0b0000_0000 |
|   10   | 0x00 0b0000_0000 |
|   11   | 0x00 0b0000_0000 |
|   12   | 0x00 0b0000_0000 |
|   13   | 0x00 0b0000_0000 |
|   14   | 0x00 0b0000_0000 |
|   15   | 0x00 0b0000_0000 |
> S 0x00 0x30 0x01 0x02 0x04 0x08 0x40 0x90 0xF7
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04   | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
|   08   | 0x00 0b0000_0000 |
|   09   | 0x00 0b0000_0000 |
|   10   | 0x00 0b0000_0000 |
|   11   | 0x00 0b0000_0000 |
|   12   | 0x00 0b0000_0000 |
|   13   | 0x00 0b0000_0000 |
|   14   | 0x00 0b0000_0000 |
|   15   | 0x00 0b0000_0000 |
```

##### T コマンド

**T** num : レジスタ表示しながら指定した回数だけトレース実行します。(nは、1以上の数値)

時間がかかる複雑な処理を1つ1つ動かしていくのは大変です。  
この機能は、機能がわかっている処理をまとめて実行し、途中経過や実行結果だけを見たい場合などに使います。  
以下は、複数回の加算を行い、結果をOutPortに出力するものです。

1. Aレジスタで、1+2+4+8を計算する。
2. Aレジスタの内容をBレジスタにコピーする。
3. Bレジスタの内容をOutPortに出力する。
4. 現在のアドレスにジャンプして停止状態にする。

```bash
> type .\Summation.td4
; 加算	Summation
    MOV A, 0       ; Aレジスタに 0 を代入し、初期化
    ADD A, 0b00_01 ; Aレジスタに 1 を加算( 2進数)
    ADD A, 0o02    ; Aレジスタに 2 を加算( 8進数)
    ADD A, 4       ; Aレジスタに 4 を加算(10進数)
    ADD A, 0x8     ; Aレジスタに 8 を加算(16進数)
    MOV B, A       ; Aレジスタの値をBレジスタにコピーする。
    OUT B          ; Bレジスタの値を出力ポートに送る。
STOP:
    JMP STOP ; ここで無限ループにして、停止状態にする。

> .\td4asm.exe -o .\Summation.hex -list .\Summation.td4

 ADDR      | BINARY    | HEX | SOURCE CODE
-----------|-----------|-----|----------------
 00 [0000] | 0011_0000 |  30 | MOV A, 0
 01 [0001] | 0000_0001 |  01 | ADD A, 1
 02 [0010] | 0000_0010 |  02 | ADD A, 2
 03 [0011] | 0000_0100 |  04 | ADD A, 4
 04 [0100] | 0000_1000 |  08 | ADD A, 8
 05 [0101] | 0100_0000 |  40 | MOV B, A
 06 [0110] | 1001_0000 |  90 | OUT B
 07 [0111] | 1111_0111 |  F7 | JMP STOP

Success! Generated 8 bytes.
Output saved to '.\Summation.hex'
```

以下は、T コマンドによる実行例です。  
最初に、5命令をTコマンドでまとめて実行し、その後は、1命令づつトレース実行して結果を確認しています。  

```bash
onnected to COM15. Press Ctrl-C to exit.
4bit CPU TD4 emulator
Reading from the serial port...
Mode: Step=true, Speed= 1000ms/inst
| PC   BP |OP-code|A register |B register |Cflag| IN port | OUT port |
|:--------|:-----:|:---------:|:---------:|:---:|:-------:|:--------:|
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
> S 0x00 0x30 0x01 0x02 0x04 0x08 0x40 0x90 0xF7
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04   | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
|   08   | 0x00 0b0000_0000 |
> T 4
| PC:01   | OP:01 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:02   | OP02 | A:0001(1) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:03   | OP:04 | A:0011(3) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:04   | OP:08 | A:0111(7) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
> T
| PC:05   | OP:40 | A:1111(F) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
> T
| PC:06   | OP:90 | A:1111(F) | B:1111(F) | C:0 | IN:0000 | OUT:0000 |
> T
| PC:07   | OP:F7 | A:1111(F) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |

```

##### B コマンド

**B** adr : ブレークポイントの参照、設定と解除を行います。

デバッグするために、プログラムを一時停止させるアドレスの設定と解除を行います。

* 引数なしで実行すると現在設定されているブレークポイントを表示します。
* アドレスを指定して実行するとブレークポイントが設定されます。
* メモリの範囲外のアドレスを指定して実行するとブレークポイントが解除されます。

また、ブレークポイントを設定してから、Mコマンドを実行すると、アドレスの位置に'B'が実行されます。

ブレークポイントを設定してから、後述するTコマンド、Gコマンドを実行すると、その位置でプログラムを停止できます。

以下はその実行例です。

1. Bコマンドで 4番地にブレイクポイントを設定する。
2. Mコマンドで ブレイクポイントの確認する。
3. Tコマンドで8ステップを実行するが、4番地にブレイクポイントが設定されているので、ここで停止する。
4. Bコマンドで 0-16番地以外の番地を指定して、ブレイクポイントを解除する。

```bash
> S 0x00 0x30 0x01 0x02 0x04 0x08 0x40 0x90 0xF7
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04   | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
> B 4
Break point: 4
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04 B | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
> T 8
| PC:01   | OP:01 | A:0000(0) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:02   | OP:02 | A:0001(1) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:03   | OP:04 | A:0011(3) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
| PC:04 B | OP:08 | A:0111(7) | B:0000(0) | C:0 | IN:0000 | OUT:0000 |
> B 17
Break point: none
> M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04   | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
```

##### G コマンド

**G** adr : プログラムを連続実行します。

* 引数なしで実行すると現在のプログラムカウンタに設定されているアドレスから実行を開始します。
* 実行を開始するアドレスを指定して実行すると、そのアドレスをプログラムカウンタに設定してから実行を開始します。

G コマンドを一度実行すると、Ctrl+Cで、強制終了する以外に停止する術はありません。
必要に応じて、B コマンドで、ブレークポイントを設定してから、G コマンドを実行して下さい。
以下はその実行例です。

```bash
 M
| Adress | OP-code          |
|:------:|:----------------:|
|   00   | 0x30 0b0011_0000 |
|   01   | 0x01 0b0000_0001 |
|   02   | 0x02 0b0000_0010 |
|   03   | 0x04 0b0000_0100 |
|   04   | 0x08 0b0000_1000 |
|   05   | 0x40 0b0100_0000 |
|   06   | 0x90 0b1001_0000 |
|   07   | 0xF7 0b1111_0111 |
|   08   | 0x00 0b0000_0000 |
> B 6
Break point: 6
> G 0
| PC:00   | OP:30 | A:1111(F) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:01   | OP:01 | A:0000(0) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:02   | OP:02 | A:0001(1) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:03   | OP:04 | A:0011(3) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:04   | OP:08 | A:0111(7) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:05   | OP:40 | A:1111(F) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
| PC:06 B | OP:90 | A:1111(F) | B:1111(F) | C:0 | IN:0000 | OUT:1111 |
```

**I**  num  : 入力ポートの値を設定します。(numは、0から15までの数値)  
IN 命令の直前に、このコマンドを実行すると、設定した値がIN 命令の実行結果に反映されます。  
値はGo言語の2進数、8進数、10進数、16進数表記で入力できます。

```bash
> I 5
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:0101 | OUT:0000 |
> I 10
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
> I 0xF
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1111 | OUT:0000 |
> i 0o10
| PC:00   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1000 | OUT:0000 |
> I 0b10_10
| PC:00   | OP:00 | A:000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
```

##### V コマンド

**V** time : 実行速度を設定します。

1命令の実行時間を設定します。単位は、ミリ秒単位です。  
デフォルトの実行時間は1000ms(1秒)に設定されていますが、このコマンドで、設定を変更できます。　　
以下の実行例は、まず、V コマンドで、現在の1命令の実行時間を確認し、その後、実行時間を120msに設定しています。  

```bash
> V
Speed= 1000ms/inst
> V 120
Speed=  120ms/inst
> T 5
| PC:01   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
| PC:02   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
| PC:03   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
| PC:04   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
| PC:05   | OP:00 | A:0000(0) | B:0000(0) | C:0 | IN:1010 | OUT:0000 |
>
```

## 5. 使用上の注意点と制約

1. **入力ポート（IN）の制限**

* 現在の実装では、入力ポート（IN A, IN B命令で参照される値）は初期状態では **`0000` 固定** となっています。
* トレース実行モードでIN命令の前に、Iコマンドで入力ポートの値を設定することで、外部スイッチによる入力をエミュレートできます。

2. **16バイト制限**

* 読み込むバイトコードが16byteを超えている場合、それ以降のデータは無視（または切り捨て）されます。

<!--
3. **画面クリアについて**
* 多くの環境で動作させるため、画面のクリア（リフレッシュ）処理は簡易的な実装（または追記形式）となっています。長時間実行するとログが流れ続けます。


4. **未定義命令の挙動**
* TD4の仕様にない命令コード（Opcode）が含まれていた場合、エミュレータは何もしない（NOP相当）か、予期しない挙動をする可能性があります。必ずアセンブラを通した正しいコードを使用してください。
-->